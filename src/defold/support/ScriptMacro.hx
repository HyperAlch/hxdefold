package defold.support;

#if macro
import haxe.io.Path;
import haxe.macro.Compiler;
import haxe.macro.Expr;
import haxe.macro.Context;
import haxe.macro.Type;
using StringTools;
using haxe.macro.Tools;

enum ScriptType {
    SCode;
    SGui;
    SRender;
}

enum PropertyType {
    PBool;
    PInt;
    PFloat;
    PHash;
    PUrl;
    PVector3;
    PVector4;
    PQuaternion;
}

class ScriptMacro {
    static function use(defoldRoot:String, outDir = "scripts") {
        var defoldRoot = sys.FileSystem.fullPath(defoldRoot).replace("\\", "/");
        if (!defoldRoot.endsWith("/"))
            defoldRoot += "/";
        var outFile = sys.FileSystem.fullPath(Compiler.getOutput()).replace("\\", "/");
        if (!StringTools.startsWith(outFile, defoldRoot))
            throw "Haxe/Lua output file should be within defold project root: " + defoldRoot;

        outDir = Path.join([defoldRoot, outDir]);

        // determine the the module name for the "require" statement,
        // based on main lua file path relative to defold project root
        var parts = outFile.substring(defoldRoot.length).split("/");
        var last = parts.length - 1;
        parts[last] = Path.withoutExtension(parts[last]);
        var requireModule = parts.join(".");

        Context.onGenerate(function(types) {
            // clear the scripts output directory
            deleteRec(outDir);
            sys.FileSystem.createDirectory(outDir);

            // collect script classes
            var scriptClasses = [];

            // these will contain a map of callback method names
            var baseScriptMethods = new Map();
            var baseGuiScriptMethods = new Map();
            var baseRenderScriptMethods = new Map();

            for (type in types) {
                switch (type) {
                    case TInst(_.get() => cl, _):
                        switch (cl) {
                            case {pack: ["defold", "support"], name: "Script"}:
                                for (field in cl.fields.get())
                                    baseScriptMethods[field.name] = true;

                            case {pack: ["defold", "support"], name: "GuiScript"}:
                                for (field in cl.fields.get())
                                    baseGuiScriptMethods[field.name] = true;

                            case {pack: ["defold", "support"], name: "RenderScript"}:
                                for (field in cl.fields.get())
                                    baseRenderScriptMethods[field.name] = true;

                            case {superClass: {t: _.get() => {pack: ["defold", "support"], name: "Script"}, params: [tData]}}:
                                scriptClasses.push({cls: cl, data: tData, type: SCode});

                            case {superClass: {t: _.get() => {pack: ["defold", "support"], name: "GuiScript"}, params: [tData]}}:
                                scriptClasses.push({cls: cl, data: tData, type: SGui});

                            case {superClass: {t: _.get() => {pack: ["defold", "support"], name: "RenderScript"}, params: [tData]}}:
                                scriptClasses.push({cls: cl, data: tData, type: SRender});

                            default:
                        }
                    default:
                }
            }

            // no script classes? nothing to do
            if (scriptClasses.length == 0)
                return;

            // this shouldn't happen at all
            if (baseScriptMethods == null)
                throw "No base Script class found!";

            // generate scripts for our classes
            for (script in scriptClasses) {
                var cl = script.cls;

                // expose the script, so it's visible to generated script
                cl.meta.add(":expose", [], cl.pos);

                // get data properties for generating `go.property` calls, which should be in the genrated script
                var props = getProperties(script.data, cl.pos);

                // generate the script...
                var b = new StringBuf();

                // add a nice header
                var posStr = Std.string(cl.pos);
                posStr = posStr.substring(5, posStr.length - 1);
                b.add('-- Generated by Haxe, DO NOT EDIT (original source: $posStr)\n\n');

                var dotPath = haxe.macro.MacroStringTools.toDotPath(cl.pack, cl.name);

                // require the main generated lua file
                b.add('local m = require "$requireModule"\n\n');

                // if we have data properties, generate go.property calls for them
                // TODO: more work should be done to support all types of default values
                if (props.length > 0) {
                    for (prop in props)
                        b.add('go.property("${prop.name}", ${prop.value})\n');
                    b.add("\n");
                }

                // make an instance of script
                b.add('local script = m.$dotPath.new()\n\n');

                var baseMethods;
                var ext;
                switch (script.type) {
                    case SCode:
                        baseMethods = baseScriptMethods;
                        ext = "script";
                    case SGui:
                        baseMethods = baseGuiScriptMethods;
                        ext = "gui_script";
                    case SRender:
                        baseMethods = baseRenderScriptMethods;
                        ext = "render_script";
                }

                // generate callback fields
                for (field in cl.fields.get()) {
                    // this is a callback field, if it's overriden from the base Script class
                    if (baseMethods.exists(field.name)) {
                        // generate arguments
                        var args = switch (field.type) {
                            case TFun(args, _):
                                [for (arg in args) arg.name].join(", ");
                            default:
                                throw new Error("Overriden class field is not a method. This can't happen! :)", field.pos);
                        }
                        // generate callback function definition
                        b.add('function ${field.name}($args)\n\tscript:${field.name}($args)\nend\n\n');
                    }
                }

                // finally, save the generated script file, using the name of the class
                var scriptDir = Path.join([outDir].concat(cl.pack));
                sys.FileSystem.createDirectory(scriptDir);
                sys.io.File.saveContent('$scriptDir/${cl.name}.$ext', b.toString());
            }
        });
    }

    // this should be in the standard library
    static function deleteRec(path:String) {
        if (!sys.FileSystem.exists(path))
            return;
        if (sys.FileSystem.isDirectory(path)) {
            for (file in sys.FileSystem.readDirectory(path))
                deleteRec('$path/$file');
            sys.FileSystem.deleteDirectory(path);
        } else {
            sys.FileSystem.deleteFile(path);
        }
    }

    static function getProperties(type:Type, pos:Position):Array<{name:String, value:String}> {
        var result = [];
        switch (type.follow()) {
            case TAnonymous(_.get() => anon):
                for (field in anon.fields) {
                    var prop = field.meta.extract("property");
                    switch (prop) {
                        case []:
                            continue;
                        case [prop]:
                            var type = getPropertyType(field.type, field.pos);
                            var value = if (prop.params.length == 0) getDefaultValue(type) else parsePropertyExpr(type, prop.params, prop.pos);
                            result.push({name: field.name, value: value});
                        default:
                            throw new Error("Only single @property metadata is allowed", field.pos);
                    }
                }
            default:
                throw new Error('Invalid component data type: ${type.toString()}. Should be a structure.', pos);
        }
        return result;
    }

    static function getPropertyType(type:Type, pos:Position):PropertyType {
        return switch (type.follow()) {
            case TInst(_.get() => {pack: ["defold"], name: "Hash"}, _): PHash;
            case TInst(_.get() => {pack: ["defold"], name: "Url"}, _): PUrl;
            case TAbstract(_.get() => {pack: ["defold"], name: "Vector3"}, _): PVector3;
            case TAbstract(_.get() => {pack: ["defold"], name: "Vector4"}, _): PVector4;
            case TInst(_.get() => {pack: ["defold"], name: "Quaternion"}, _): PQuaternion;
            case TAbstract(_.get() => {pack: [], name: "Int"}, _): PInt;
            case TAbstract(_.get() => {pack: [], name: "Float"}, _): PFloat;
            case TAbstract(_.get() => {pack: [], name: "Bool"}, _): PBool;
            default: throw new Error('Unsupported type for script property: ${type.toString()}', pos);
        }
    }

    static function getDefaultValue(type:PropertyType):String {
        return switch (type) {
            case PHash: 'hash("")';
            case PUrl: 'msg.url()';
            case PVector3: 'vmath.vector3()';
            case PVector4: 'vmath.vector4()';
            case PBool: 'false';
            case PInt: '0';
            case PFloat: '0.0';
            case PQuaternion: 'vmath.quat()';
        }
    }

    static function parsePropertyExpr(type:PropertyType, exprs:Array<Expr>, pos:Position):String {
        return switch [type, exprs] {
            case [PBool, [{expr: EConst(CIdent(s = "true" | "false"))}]]:
                s;
            case [PHash, [{expr: EConst(CString(s))}]]:
                'hash(${haxe.Json.stringify(s)})';
            case [PUrl, _]:
                throw new Error("No default value allowed for URL properties", pos);
            case [PFloat, [{expr: EConst(CFloat(s) | CInt(s))}]]:
                s;
            case [PInt, [{expr: EConst(CInt(s))}]] if (Std.parseInt(s) != null):
                s;
            case [PVector3, [{expr: EConst(CFloat(x) | CInt(x))}, {expr: EConst(CFloat(y) | CInt(y))}, {expr: EConst(CFloat(z) | CInt(z))}]]:
                'vmath.vector3($x, $y, $z)';
            case [PVector4, [{expr: EConst(CFloat(x) | CInt(x))}, {expr: EConst(CFloat(y) | CInt(y))}, {expr: EConst(CFloat(z) | CInt(z))}, {expr: EConst(CFloat(w) | CInt(w))}]]:
                'vmath.vector4($x, $y, $z, $w)';
            case [PQuaternion, [{expr: EConst(CFloat(x) | CInt(x))}, {expr: EConst(CFloat(y) | CInt(y))}, {expr: EConst(CFloat(z) | CInt(z))}, {expr: EConst(CFloat(w) | CInt(w))}]]:
                'vmath.quat($x, $y, $z, $w)';
            default:
                throw new Error('Invalid @property value for type ${type.getName().substr(1)}', pos);
        }
    }
}
#end
